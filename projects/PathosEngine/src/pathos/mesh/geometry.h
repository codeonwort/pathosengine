#pragma once

#include "pathos/rhi/gl_handles.h"
#include "pathos/rhi/buffer.h"
#include "pathos/rhi/render_command_list.h"

#include "badger/types/vector_types.h"
#include "badger/math/aabb.h"

namespace pathos {

	class MeshGeometry {

	public:
		MeshGeometry();
		virtual ~MeshGeometry();

		MeshGeometry(const MeshGeometry&)            = delete;
		MeshGeometry& operator=(const MeshGeometry&) = delete;

		void setDrawArraysMode(bool value) { drawArraysMode = value; }

		// #todo-draw-prim: Remove this and call cmdList.drawElements() directly
		void drawPrimitive(RenderCommandList& cmdList, int32 instanceCount = 1);

		inline vector3 getPosition(uint32 index) const { return positionData[index]; }
		uint32 getIndexCount() const;

		void updateNormalData(const std::vector<vector3>& inNormals);

		// #note-geometry:
		// - GL uses GLsizeiptr(int64), but I'm restricting to uint32.
		// - 'length' can be confusing. It means the number of elements, not total bytes.
		void updatePositionData(const GLfloat* data, uint32 length);
		void updateUVData(const GLfloat* data, uint32 length, bool bFlipY = false);
		void updateNormalData(const GLfloat* data, uint32 length);
		void updateTangentData(const GLfloat* data, uint32 length);
		void updateBitangentData(const GLfloat* data, uint32 length);

		void updateIndexData(const GLuint* data, uint32 length);
		void updateIndex16Data(const uint16* data, uint32 length);

		void calculateNormals();
		void calculateTangentBasis();

		void calculateLocalBounds();
		inline const AABB& getLocalBounds() const { return localBounds; }

		// Definitions are generated by macro. See DEFINE_ACTIVATE_VAO.
		void activate_position(RenderCommandList& cmdList);
		void activate_position_uv(RenderCommandList& cmdList);
		void activate_position_normal(RenderCommandList& cmdList);
		void activate_position_uv_normal(RenderCommandList& cmdList);
		void activate_position_uv_normal_tangent_bitangent(RenderCommandList& cmdList);
		void deactivate(RenderCommandList& cmdList);

		void activateIndexBuffer(RenderCommandList& cmdList);
		void deactivateIndexBuffer(RenderCommandList& cmdList);

		void dispose();

	private:
		void createVAO_position(RenderCommandList& cmdList);
		void createVAO_position_uv(RenderCommandList& cmdList);
		void createVAO_position_normal(RenderCommandList& cmdList);
		void createVAO_position_uv_normal(RenderCommandList& cmdList);
		void createVAO_position_uv_normal_tangent_bitangent(RenderCommandList& cmdList);

		void calculateNormals_array();
		void calculateNormals_indexed();

	public:
		bool bCalculateLocalBounds = true;

	private:
		std::vector<vector3> positionData;
		std::vector<vector2> uvData;
		std::vector<vector3> normalData;
		std::vector<vector3> tangentData;
		std::vector<vector3> bitangentData;

		// #todo-geometry: Support both GL_UNSIGNED_SHORT (16bit) and GL_UNSIGNED_INT (32bit)
		std::vector<GLuint>  indexData;

		AABB localBounds;

		// Vertex buffer
		GLuint positionBuffer  = 0;
		GLuint uvBuffer        = 0;
		GLuint normalBuffer    = 0;
		GLuint tangentBuffer   = 0;
		GLuint bitangentBuffer = 0;
		
		// Index buffer (suballocated from global index buffer pool)
		uint64 indexBufferOffset = BufferPool::INVALID_OFFSET;
		uint64 indexBufferBytes = 0;

		// VAOs
		GLuint vao_position                             = 0;
		GLuint vao_position_uv                          = 0;
		GLuint vao_position_normal                      = 0;
		GLuint vao_position_uv_normal                   = 0;
		GLuint vao_position_uv_normal_tangent_bitangent = 0;

		bool drawArraysMode = false; // If true, use glDrawArrays(). Otherwise, use glDrawElements().
	};

}
